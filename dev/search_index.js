var documenterSearchIndex = {"docs":
[{"location":"api/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"DynSolve.jl provides multiple solver backends for dynamic systems.","category":"page"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"Each solver implements a unified interface:","category":"page"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"sol = solve(system, solver)","category":"page"},{"location":"api/solvers/#1.-PerturbationSolver()","page":"Solvers","title":"1. PerturbationSolver()","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"Linear perturbation (Blanchard–Kahn) approach.  Used for standard DSGE or RBC models.","category":"page"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"sol = solve(lin, PerturbationSolver())","category":"page"},{"location":"api/solvers/#Output","page":"Solvers","title":"Output","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"Dict(:G1 => [0.95], :impact => [0.1])","category":"page"},{"location":"api/solvers/#2.-ProjectionSolver()","page":"Solvers","title":"2. ProjectionSolver()","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"Nonlinear projection / collocation method.  Suitable for models with large shocks or occasionally binding constraints.","category":"page"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"sol = solve(model, ProjectionSolver())","category":"page"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"(Currently a placeholder — to be implemented in the next version.)","category":"page"},{"location":"api/solvers/#3.-VFISolver()","page":"Solvers","title":"3. VFISolver()","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"Value Function Iteration (VFI) for heterogeneous-agent models (HANK / incomplete markets).","category":"page"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"sol = solve(model, VFISolver())","category":"page"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"Also a placeholder for now, but designed to handle dynamic programming formulations.","category":"page"},{"location":"api/solvers/#Design-Philosophy","page":"Solvers","title":"Design Philosophy","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"Solver Type Use Case\nPerturbationSolver Linear / local DSGE / RBC\nProjectionSolver Global nonlinear OBC / large shocks\nVFISolver Dynamic programming Heterogeneous agents","category":"page"},{"location":"api/solvers/#Example","page":"Solvers","title":"Example","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"sol = solve(lin, PerturbationSolver())","category":"page"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"api/steady/#Steady-State-Computation","page":"Steady State","title":"Steady State Computation","text":"","category":"section"},{"location":"api/steady/#steadystate(model::Model)","page":"Steady State","title":"steadystate(model::Model)","text":"","category":"section"},{"location":"api/steady/","page":"Steady State","title":"Steady State","text":"Computes the deterministic steady state of a model.","category":"page"},{"location":"api/steady/","page":"Steady State","title":"Steady State","text":"ss = steadystate(model)","category":"page"},{"location":"api/steady/#Returns","page":"Steady State","title":"Returns","text":"","category":"section"},{"location":"api/steady/","page":"Steady State","title":"Steady State","text":"A Dict{Symbol, Float64} mapping each variable name to its steady-state value, e.g.","category":"page"},{"location":"api/steady/","page":"Steady State","title":"Steady State","text":"Dict(:k => 1.0, :c => 0.5, :y => 1.0)","category":"page"},{"location":"api/steady/#Internals","page":"Steady State","title":"Internals","text":"","category":"section"},{"location":"api/steady/","page":"Steady State","title":"Steady State","text":"The steady-state equations are derived from the model’s symbolic equations.\nNonlinear equations are solved using NLsolve.jl.\nInitial guesses can later be passed as an argument (planned).","category":"page"},{"location":"api/steady/#Example","page":"Steady State","title":"Example","text":"","category":"section"},{"location":"api/steady/","page":"Steady State","title":"Steady State","text":"ss = steadystate(model)\nprintln(ss[:k])    ## access steady-state capital","category":"page"},{"location":"api/steady/#Notes","page":"Steady State","title":"Notes","text":"","category":"section"},{"location":"api/steady/","page":"Steady State","title":"Steady State","text":"For models with exogenous AR(1) shocks, the steady-state value is typically zero.\nThe steady-state module can later support symbolic steady states using ModelingToolkit.solve_for.","category":"page"},{"location":"examples/nk/#Example:-New-Keynesian-Model","page":"New Keynesian","title":"Example: New Keynesian Model","text":"","category":"section"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"This example demonstrates how to use DynSolve.jl for a New Keynesian (NK) model.","category":"page"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"","category":"page"},{"location":"examples/nk/#Model-Setup","page":"New Keynesian","title":"Model Setup","text":"","category":"section"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"using DynSolve\n\nnk_model = @dgesys begin\n    var x(t), pi(t), i(t)\n    shock εd(t), εm(t)\n    param β=0.99, κ=0.1, φπ=1.5, φx=0.5, ρd=0.8, ρm=0.5, σd=0.01, σm=0.01\n\n    IS        ~ x(t) ~ x(t+1) - (i(t) - pi(t+1))\n    NKPC      ~ pi(t) ~ β*pi(t+1) + κ*x(t)\n    Taylor    ~ i(t) ~ φπ*pi(t) + φx*x(t) + εm(t)\n\n    demand    ~ εd(t+1) ~ ρd*εd(t) + σd*εd(t)\n    monetary  ~ εm(t+1) ~ ρm*εm(t) + σm*εm(t)\nend","category":"page"},{"location":"examples/nk/#Compute-and-Solve","page":"New Keynesian","title":"Compute and Solve","text":"","category":"section"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"ss = steadystate(nk_model)\nlin = linearize(nk_model, ss)\nsol = solve(lin, PerturbationSolver())","category":"page"},{"location":"examples/nk/#Impulse-Response:-Monetary-Policy-Shock","page":"New Keynesian","title":"Impulse Response: Monetary Policy Shock","text":"","category":"section"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"irf = impulse_response(sol; shock=:εm, horizon=20)","category":"page"},{"location":"examples/nk/#Reporting","page":"New Keynesian","title":"Reporting","text":"","category":"section"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"report = analyze(nk_model, ss, sol, irf)\nexport_report(report, \"nk_report.md\")","category":"page"},{"location":"examples/nk/#Notes","page":"New Keynesian","title":"Notes","text":"","category":"section"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"This stylized NK example illustrates:","category":"page"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"sticky prices via the Phillips Curve \nmonetary policy reaction through a Taylor rule \ndemand shock propagation through the IS curve ","category":"page"},{"location":"examples/nk/","page":"New Keynesian","title":"New Keynesian","text":"While simple, it provides a template for more complex DSGE systems.","category":"page"},{"location":"examples/rbc/#Example:-Real-Business-Cycle-(RBC)-Model","page":"RBC","title":"Example: Real Business Cycle (RBC) Model","text":"","category":"section"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"This page demonstrates how to define and solve a simple RBC model using DynSolve.jl.","category":"page"},{"location":"examples/rbc/#Model-Definition","page":"RBC","title":"Model Definition","text":"","category":"section"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"using DynSolve\n\nmodel = @dgesys begin\n    var c(t), k(t), y(t), r(t)\n    shock εA(t)\n    param α=0.36, β=0.99, δ=0.025, ρA=0.9, σA=0.01\n\n    y(t)      ~ exp(a(t)) * k(t)^α\n    a(t+1)    ~ ρA * a(t) + σA * εA(t)\n    Euler     ~ 1/c(t) ~ β * (1/c(t+1)) * (1 + r(t+1) - δ)\n    k(t+1)    ~ y(t) - c(t) + (1-δ)*k(t)\n    r(t)      ~ α * y(t)/k(t)\nend","category":"page"},{"location":"examples/rbc/#Steady-State","page":"RBC","title":"Steady State","text":"","category":"section"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"ss = steadystate(model)","category":"page"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"Outputs (placeholder):","category":"page"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"Dict(:k => 1.0, :c => 0.5, :y => 1.0)","category":"page"},{"location":"examples/rbc/#Linearization-and-Solution","page":"RBC","title":"Linearization and Solution","text":"","category":"section"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"lin = linearize(model, ss)\nsol = solve(lin, PerturbationSolver())\n","category":"page"},{"location":"examples/rbc/#Impulse-Response-Functions","page":"RBC","title":"Impulse Response Functions","text":"","category":"section"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"irf = impulse_response(sol; shock=:εA)","category":"page"},{"location":"examples/rbc/#Report-Generation","page":"RBC","title":"Report Generation","text":"","category":"section"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"report = analyze(model, ss, sol, irf)\nexport_report(report, \"rbc_report.md\")","category":"page"},{"location":"examples/rbc/#Interpretation","page":"RBC","title":"Interpretation","text":"","category":"section"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"Even though this example uses placeholder numbers, the workflow mirrors a full RBC model pipeline:","category":"page"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"symbolic model specification\nautomated steady-state computation\nlinearization\nperturbation solution\nIRFs and reporting","category":"page"},{"location":"examples/rbc/","page":"RBC","title":"RBC","text":"","category":"page"},{"location":"api/analysis/#Analysis-and-Impulse-Responses","page":"Analysis","title":"Analysis and Impulse Responses","text":"","category":"section"},{"location":"api/analysis/#impulse_response(solution;-shock,-horizon40)","page":"Analysis","title":"impulse_response(solution; shock, horizon=40)","text":"","category":"section"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"Generates impulse response functions (IRFs) given a solved model.","category":"page"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"irf = impulse_response(sol; shock=:εA, horizon=40)","category":"page"},{"location":"api/analysis/#Returns","page":"Analysis","title":"Returns","text":"","category":"section"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"A dictionary of time series (arrays):","category":"page"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"Dict(:y => [1.0, 0.95, 0.9, ...])","category":"page"},{"location":"api/analysis/#analyze(model,-ss,-sol,-irf)","page":"Analysis","title":"analyze(model, ss, sol, irf)","text":"","category":"section"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"Computes and summarizes post-solution statistics.","category":"page"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"report = analyze(model, ss, sol, irf)","category":"page"},{"location":"api/analysis/#Returns-2","page":"Analysis","title":"Returns","text":"","category":"section"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"A dictionary containing:","category":"page"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"Dict(:summary => \"Analysis complete\")","category":"page"},{"location":"api/analysis/#Planned-Features","page":"Analysis","title":"Planned Features","text":"","category":"section"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"variance decomposition\nsimulation of stochastic paths\ncomparison across models (e.g., policy experiments)\nPrettyTables output for markdown / HTML reports","category":"page"},{"location":"api/analysis/#Example","page":"Analysis","title":"Example","text":"","category":"section"},{"location":"api/analysis/","page":"Analysis","title":"Analysis","text":"irf = impulse_response(sol; shock=:εA)\nreport = analyze(model, ss, sol, irf)","category":"page"},{"location":"quickstart/#Quickstart","page":"Quick Start","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"This guide walks you through installing and using DynSolve.jl for the first time.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"quickstart/#Installation","page":"Quick Start","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"DynSolve.jl is a Julia package. You can develop it locally or install from source once published.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using Pkg\nPkg.add(url=\"https://github.com/yryrena/DynSolve.jl\")\n\nIf you are developing locally (recommended for research):\n","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"{bash} cd /path/to/DynSolve julia –project=.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"\nThen in the Julia REPL:\n","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia using Pkg Pkg.activate(\".\") Pkg.instantiate()","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"\n## Basic Usage Example\n\nThe following minimal script runs the entire DynSolve workflow on a simple RBC model:\n","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"julia using DynSolve","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"model = @dgesys begin     var c(t), k(t), y(t), r(t)     shock εA(t)     param α=0.36, β=0.99, δ=0.025, ρA=0.9, σA=0.01","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"y(t)   ~ exp(a(t)) * k(t)^α\na(t+1) ~ ρA * a(t) + σA * εA(t)\nEuler  ~ 1/c(t) ~ β * (1/c(t+1)) * (1 + r(t+1) - δ)\nk(t+1) ~ y(t) - c(t) + (1-δ)*k(t)\nr(t)   ~ α * y(t)/k(t)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"end","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"ss  = steadystate(model) lin = linearize(model, ss) sol = solve(lin, PerturbationSolver()) irf = impulseresponse(sol; shock=:εA) report = analyze(model, ss, sol, irf) exportreport(report, \"rbc_report.md\")","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"\n## Directory Overview\n\nA typical DynSolve project contains: \n","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"{bash} DynSolve/   ├── Project.toml ├── Manifest.toml ├── README.md ├── LICENSE ├── src/            ## core package source ├── test/           ## automated tests ├── examples/       ## runnable model demos ├── docs/           ## documentation (Documenter.jl) ├── scripts/        ## benchmarks / figures / experiments └── .gitignore ```","category":"page"},{"location":"quickstart/#Next-Steps","page":"Quick Start","title":"Next Steps","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"See Model Specification for the @dgesys macro.  \nTry RBC Example and NK Example.  \nExplore different solvers in Solvers.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"api/model/#Model-Specification-(@dgesys-and-Model)","page":"Model","title":"Model Specification (@dgesys and Model)","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"DynSolve models are defined symbolically using the @dgesys macro, built on top of ModelingToolkit.jl.   This makes the model human-readable, reproducible, and automatically differentiable.","category":"page"},{"location":"api/model/#@dgesys-Macro","page":"Model","title":"@dgesys Macro","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"model = @dgesys begin\n    var c(t), k(t), y(t)\n    shock εA(t)\n    param α=0.36, β=0.99, δ=0.025\n\n    y(t)      ~ k(t)^α\n    Euler     ~ 1/c(t) ~ β*(1/c(t+1))*(1+α*k(t+1)^(α-1)-δ)\n    k(t+1)    ~ y(t) - c(t) + (1-δ)*k(t)\nend","category":"page"},{"location":"api/model/#Keywords","page":"Model","title":"Keywords","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Keyword Description\nvar Endogenous variables depending on time t.\nshock Exogenous stochastic processes.\nparam Model parameters (with initial values).\n~ Represents an equation (equality).","category":"page"},{"location":"api/model/#Model-Struct","page":"Model","title":"Model Struct","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"struct Model\n    variables::Vector{Symbol}\n    shocks::Vector{Symbol}\n    parameters::Vector{Symbol}\n    equations::Vector{Equation}\nend","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"Each @dgesys call returns a Model object that stores the symbolic system and metadata for steady-state and solution steps.","category":"page"},{"location":"api/model/#Notes","page":"Model","title":"Notes","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"You can include expectations (E_t[x(t+1)]) symbolically; future releases will map this to perturbation logic.\nParameters can be re-assigned after model creation:\nmodel.parameters[:β] = 0.98\nEquations are internally represented as ModelingToolkit.Equation objects.","category":"page"},{"location":"#DynSolve.jl","page":"Home","title":"DynSolve.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DynSolve.jl is a Julia toolkit for defining, solving, and analyzing dynamic macroeconomic models (DSGE / RBC / New Keynesian / heterogeneous agent). The goal is to let you:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Specify a model in symbolic form (variables, shocks, equilibrium conditions).\nAutomatically compute steady states.\nLinearize (or higher-order expand) around the steady state.\nSolve for decision rules using perturbation, projection, or value function iteration.\nGenerate impulse responses, simulations, and summary reports.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DynSolve aims to be an open, high-performance alternative to traditional MATLAB/Octave-based tools (e.g. Dynare) with native Julia performance and integration with ModelingToolkit.jl.","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DynSolve\n\n## 1. define a model\nmodel = @dgesys begin\n    var c(t), k(t), y(t), r(t)\n    shock εA(t)\n    param α=0.36, β=0.99, δ=0.025, ρA=0.9, σA=0.01\n\n    y(t)      ~ exp(a(t)) * k(t)^α\n    a(t+1)    ~ ρA * a(t) + σA * εA(t)\n    Euler     ~ 1/c(t)    ~ β * (1/c(t+1)) * (1 + r(t+1) - δ)\n    k(t+1)    ~ y(t) - c(t) + (1-δ)*k(t)\n    r(t)      ~ α * y(t)/k(t)\nend\n\n## 2. compute steady state\nss = steadystate(model)\n\n## 3. linearize around steady state\nlin = linearize(model, ss; order=1)\n\n## 4. solve (e.g. perturbation / Blanchard-Kahn style)\nsol = solve(lin, PerturbationSolver())\n\n## 5. get IRFs\nirf = impulse_response(sol; shock=:εA, horizon=40)\n\n## 6. analyze and export report\nreport = analyze(model, ss, sol, irf)\nexport_report(report, \"rbc_report.md\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This workflow is designed to mirror the typical DSGE workflow:","category":"page"},{"location":"","page":"Home","title":"Home","text":"write FOCs / equilibrium conditions once \nget steady state, policy functions, impulse responses automatically \nproduce a structured report that you can drop into a paper or presentation ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Design Goals","category":"page"},{"location":"","page":"Home","title":"Home","text":"Symbolic first. Models are declared as symbolic systems using ModelingToolkit.jl. That means we can take Jacobians, compute steady states, and generate code automatically.\nFast. Julia-level performance close to C, without MATLAB/Octave licensing.\nExtensible. Projection methods and value function iteration are first-class, so heterogeneous agent and occasionally binding constraint models are not an afterthought.\nReproducible. The entire analysis pipeline (steady state → IRFs → report)","category":"page"},{"location":"","page":"Home","title":"Home","text":"is scripted and version-controlled, not hidden in a notebook.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Status","category":"page"},{"location":"","page":"Home","title":"Home","text":"DynSolve.jl is under active development. Some solvers are stubs or illustrative placeholders.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The public API is being stabilized around:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@dgesys : model declaration macro\nsteadystate : steady state computation\nlinearize : symbolic linearization / perturbation\nsolve : numeric solution (multiple solver backends)\nimpulse_response : IRFs\nanalyze : summary stats and diagnostics\nexport_report : markdown / HTML reporting","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are encouraged to prototype, extend, and open issues.","category":"page"},{"location":"api/linear/#Linearization-and-Perturbation","page":"Linearization","title":"Linearization and Perturbation","text":"","category":"section"},{"location":"api/linear/#linearize(model::Model,-ss::Dict;-order1)","page":"Linearization","title":"linearize(model::Model, ss::Dict; order=1)","text":"","category":"section"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"Performs symbolic linearization (or higher-order expansion) around a steady state.","category":"page"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"lin = linearize(model, ss; order=1)","category":"page"},{"location":"api/linear/#Returns","page":"Linearization","title":"Returns","text":"","category":"section"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"A dictionary containing matrices or Jacobians such as:","category":"page"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"Dict(:A => [0.9], :B => [0.1])","category":"page"},{"location":"api/linear/#Method","page":"Linearization","title":"Method","text":"","category":"section"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"compute Jacobians of the model equations with respect to variables and shocks \nsubstitute steady-state values \nreturn coefficient matrices for the state-space representation: x_t+1 = A x_t + B varepsilon_t","category":"page"},{"location":"api/linear/#Higher-Order-Perturbations","page":"Linearization","title":"Higher-Order Perturbations","text":"","category":"section"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"Future releases will include:","category":"page"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"2nd and 3rd order perturbation methods.\nAutomatic symbolic differentiation for nonlinear terms.","category":"page"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"","category":"page"},{"location":"api/linear/#Example","page":"Linearization","title":"Example","text":"","category":"section"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"lin = linearize(model, ss)\ndisplay(lin[:A])","category":"page"},{"location":"api/linear/","page":"Linearization","title":"Linearization","text":"","category":"page"},{"location":"api/report/#Reporting","page":"Report","title":"Reporting","text":"","category":"section"},{"location":"api/report/#export_report(report::Dict,-path::String)","page":"Report","title":"export_report(report::Dict, path::String)","text":"","category":"section"},{"location":"api/report/","page":"Report","title":"Report","text":"Exports a markdown or HTML report summarizing the model analysis.","category":"page"},{"location":"api/report/","page":"Report","title":"Report","text":"export_report(report, \"rbc_report.md\")","category":"page"},{"location":"api/report/#Behavior","page":"Report","title":"Behavior","text":"","category":"section"},{"location":"api/report/","page":"Report","title":"Report","text":"writes a simple markdown file containing model summary and results \ncan later be extended to generate plots and styled HTML output ","category":"page"},{"location":"api/report/#Example","page":"Report","title":"Example","text":"","category":"section"},{"location":"api/report/","page":"Report","title":"Report","text":"report = Dict(:summary => \"Steady state and IRFs computed successfully.\")\nexport_report(report, \"results/summary.md\")","category":"page"},{"location":"api/report/","page":"Report","title":"Report","text":"Creates a file:","category":"page"},{"location":"api/report/","page":"Report","title":"Report","text":"# DynSolve Report\n## Summary\nSteady state and IRFs computed successfully.","category":"page"},{"location":"api/report/#Future-Extensions","page":"Report","title":"Future Extensions","text":"","category":"section"},{"location":"api/report/","page":"Report","title":"Report","text":"integration with Weave.jl for LaTeX and PDF reports \nauto-embedding plots from Plots.jl \ncomparative analysis tables across models ","category":"page"},{"location":"api/report/","page":"Report","title":"Report","text":"","category":"page"},{"location":"api/report/#Notes","page":"Report","title":"Notes","text":"","category":"section"},{"location":"api/report/","page":"Report","title":"Report","text":"Reports are designed to be lightweight and reproducible: plain text files, version-controlled with the model code.","category":"page"}]
}
